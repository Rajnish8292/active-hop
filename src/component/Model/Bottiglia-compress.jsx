/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/bottiglia-compress.glb --transform 
Files: public/bottiglia-compress.glb [1.75MB] > D:\workspace\1_projects\active-hop\bottiglia-compress-transformed.glb [93.31KB] (95%)
*/
"use client";
import React, { useEffect, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { ShaderMaterial } from "three";
import { useLoader } from "@react-three/fiber";
import { TextureLoader } from "three";
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";
import gsap from "gsap";
import { useRecoilState } from "recoil";
import { flavor_atom } from "@/store/flavors_atom";
const VERTEX_SHADER = `
varying vec3 pos;
varying vec2 vUv;
void main() {
    vUv = uv;
    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
    gl_Position = projectionMatrix * modelViewPosition; 
}
`;

const FRAGMENT_SHADER = `
  varying vec2 vUv; 
  uniform sampler2D uSourceTexture;
  uniform sampler2D uTargetTexture;
  uniform float uTextureProgress;
  uniform float uPixel;
  uniform bool uIsPixelated;

  void main() {
    float pixelCount = uPixel;
    vec2 flippedUV = vec2(vUv.x, 1.0-vUv.y);
  if(pixelCount == 512.0) {

    vec4 sourceTexture = texture2D(uSourceTexture, flippedUV);
    vec4 targetTexture = texture2D(uTargetTexture, flippedUV);
    vec4 color = mix(sourceTexture, targetTexture, uTextureProgress);
    gl_FragColor = color;

   } else {

    vec2 pixelatedUV = floor( flippedUV * pixelCount) / pixelCount;
    vec4 sourceTexture = texture2D(uSourceTexture, pixelatedUV);
    vec4 targetTexture = texture2D(uTargetTexture, pixelatedUV);
    vec4 color = mix(sourceTexture, targetTexture, uTextureProgress);
    gl_FragColor = color;
    }

  }
`;
export function Model(props) {
  const group = React.useRef();
  const isAnimatingRef = useRef(false);
  const currentTweenRef = useRef(null);

  const animationQueueRef = useRef([]);

  const { nodes, materials, animations } = useGLTF(
    "/bottiglia-compress-transformed.glb"
  );

  const initialTexture = useLoader(
    TextureLoader,
    "texture/ActiveHop_etichetta__01_trail.jpg"
  );
  const uniforms = useRef({
    uPixel: { value: 512 },
    uIsPixelated: { value: true },
    uSourceTexture: { value: initialTexture },
    uTargetTexture: { value: initialTexture },
    uTextureProgress: { value: 1.0 },
  });

  const [currentFlavor, setCurrentFlavor] = useRecoilState(flavor_atom);

  const targetRotation = useRef(new THREE.Euler(0, Math.PI / 2, 0)); // current rotation
  const currentRotation = useRef(new THREE.Euler(0, Math.PI / 2, 0));
  const scale = useRef(1); // current scale
  const targetScale = useRef(1); // desired scale based on mouse

  const shaderMaterial = useRef(null);
  const material = new ShaderMaterial();
  material.fragmentShader = FRAGMENT_SHADER;
  material.vertexShader = VERTEX_SHADER;
  material.uniforms = uniforms.current;
  shaderMaterial.current = material;

  const changeTextureTo = (url) => {
    uniforms.current.uSourceTexture = { ...uniforms.current.uTargetTexture };
    uniforms.current.uTargetTexture = { value: new TextureLoader().load(url) };
    shaderMaterial.current.uniformsNeedUpdate = true;
    uniforms.current.uTextureProgress.value = 0;
    const tween = gsap.to(uniforms.current.uTextureProgress, {
      value: 1,
      duration: 0.25,
    });
  };

  const animateAndChangeTexture = (url) => {
    const createTimeline = (url) => {
      const tl = gsap.timeline({ paused: true });
      let isAnimated = false;

      tl.to(uniforms.current.uPixel, {
        value: 32,
        duration: 0.25,
        ease: "expo.out",
        onUpdate: function () {
          const progress = this.progress() * 100;
          if (progress >= 50 && !isAnimated) {
            changeTextureTo(url);
            isAnimated = true;
          }
        },
      }).to(uniforms.current.uPixel, {
        value: 512,
        duration: 0.75,
        delay: 0.25,
        ease: "expo.in",
      });

      // When done, trigger next animation
      tl.eventCallback("onComplete", () => {
        isAnimatingRef.current = false;
        currentTweenRef.current = null;
        playNextAnimation();
      });

      return tl;
    };

    const playNextAnimation = () => {
      if (animationQueueRef.current.length === 0 || isAnimatingRef.current)
        return;
      const next = animationQueueRef.current.shift();
      isAnimatingRef.current = true;
      currentTweenRef.current = next;
      next.play();
    };

    // --- main logic ---
    const timelineInstance = createTimeline(url);

    if (isAnimatingRef.current) {
      animationQueueRef.current.push(timelineInstance);
    } else {
      isAnimatingRef.current = true;
      currentTweenRef.current = timelineInstance;
      timelineInstance.play();
    }
  };

  const mouseMoveHandler = (e) => {
    const { clientX: x, clientY: y } = e;
    const { innerWidth: width, innerHeight: height } = window;

    // normalize mouse: -1 -> 1
    const normalizedX = (x - width / 2) / (width / 2);
    const normalizedY = (y - height / 2) / (height / 2);

    const maxRotation = Math.PI / 4;
    targetRotation.current.x = normalizedY * maxRotation;
    targetRotation.current.z = normalizedX * maxRotation;

    const distanceFromCenter = Math.pow(
      Math.pow(normalizedX, 2) + Math.pow(normalizedY, 2),
      0.5
    );

    const minScale = 0.9;
    const maxScale = 1.2;
    const exponent = 2;
    targetScale.current =
      minScale + Math.pow(distanceFromCenter, exponent) * (maxScale - minScale);
  };

  useEffect(() => {
    animateAndChangeTexture(currentFlavor.url);
    console.log("changed flavor to", currentFlavor);
  }, [currentFlavor]);

  useEffect(() => {
    window.addEventListener("mousemove", mouseMoveHandler);

    return () => window.removeEventListener("mousemove", mouseMoveHandler);
  });

  useFrame(() => {
    if (!group.current) return;
    currentRotation.current.x = THREE.MathUtils.lerp(
      currentRotation.current.x,
      targetRotation.current.x,
      0.05
    );
    currentRotation.current.z = THREE.MathUtils.lerp(
      currentRotation.current.z,
      targetRotation.current.z,
      0.05
    );
    group.current.rotation.set(
      currentRotation.current.x,
      0,
      currentRotation.current.z
    );
    // smooth scale
    scale.current = THREE.MathUtils.lerp(
      scale.current,
      targetScale.current,
      0.05
    );
    group.current.scale.set(scale.current, scale.current, scale.current);
  });

  return (
    <group ref={group}>
      <group
        {...props}
        dispose={null}
        scale={[18, 18, 18]}
        position={[0, -1.5, 0]}
        rotation={[0, Math.PI / 2, 0]}
      >
        <group>
          <group name="Bottiglia">
            <mesh
              name="Tappo"
              geometry={nodes.Tappo.geometry}
              material={materials.Mat}
            />
          </group>
          <mesh
            name="Etichetta"
            geometry={nodes.Etichetta.geometry}
            material={shaderMaterial.current}
            position={[0, 0.069, 0]}
            rotation={[Math.PI / 2, 0, -Math.PI]}
          />
          <mesh
            name="Bottiglia_1"
            geometry={nodes.Bottiglia_1.geometry}
            material={materials.Mat}
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/bottiglia-compress-transformed.glb");
